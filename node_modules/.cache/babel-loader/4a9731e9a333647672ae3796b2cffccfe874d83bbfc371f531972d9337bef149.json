{"ast":null,"code":"import { CONDITIONAL_OPERATORS, RESERVED_NAMES } from \"../internal/internalConstants.js\";\nimport { ExpressionQualifier } from \"./expression/ExpressionQualifier.js\";\n/**\n * @description\n * Used for variable or conditional expressions\n * <b>Learn more:</b> {@link https://cloudinary.com/documentation/user_defined_variables#arithmetic_expressions|Arithmetic expressions }\n * @namespace Expression\n * @memberOf Qualifiers\n */\n/**\n * @summary qualifier\n * @memberOf Qualifiers.Expression\n * @return {Qualifiers.Expression.ExpressionQualifier}\n */\nfunction expression(exp) {\n  // Prepare the CONDITIONAL_OPERATORS object to be used in a regex\n  // Properly escape |, +, ^ and *\n  // This step also adds a regex space ( \\s ) around each operator, since these are only replaced when wrapped with spaces\n  // $foo * $bar is replaced to $foo_mul_$bar\n  // $foo*bar is treated AS-IS.\n  var reservedOperatorList = Object.keys(CONDITIONAL_OPERATORS).map(function (key) {\n    return \"\\\\s\".concat(key.replace(/(\\*|\\+|\\^|\\|)/g, '\\\\$1'), \"\\\\s\");\n  });\n  // reservedOperatorList is now an array of values, joining with | creates the regex list\n  var regexSafeOperatorList = reservedOperatorList.join('|');\n  var operatorsReplaceRE = new RegExp(\"(\".concat(regexSafeOperatorList, \")\"), \"g\");\n  // First, we replace all the operators\n  // Notice how we pad the matched operators with `_`, this is following the step above.\n  // This turns $foo * $bar into $foo_mul_$bar (notice how the spaces were replaced with an underscore\n  var stringWithOperators = exp.toString().replace(operatorsReplaceRE, function (match) {\n    // match contains spaces around the expression, we need to trim it as the original list\n    // does not contain spaces.\n    return \"_\".concat(CONDITIONAL_OPERATORS[match.trim()], \"_\");\n  });\n  // Handle reserved names (width, height, etc.)\n  var ReservedNames = Object.keys(RESERVED_NAMES);\n  var regexSafeReservedNameList = ReservedNames.join('|');\n  // Gather all statements that begin with a dollar sign, underscore or a space\n  // Gather all RESERVED NAMES\n  // $foo_bar is matched\n  // height is matched\n  var reservedNamesRE = new RegExp(\"(\\\\$_*[^_ ]+)|\".concat(regexSafeReservedNameList), \"g\");\n  // Since this regex captures both user variables and our reserved keywords, we need to add some logic in the replacer\n  var stringWithVariables = stringWithOperators.replace(reservedNamesRE, function (match) {\n    // Do not do anything to user variables (anything starting with $)\n    if (match.startsWith('$')) {\n      return match;\n    } else {\n      return RESERVED_NAMES[match] || match;\n    }\n  });\n  // Serialize remaining spaces with an underscore\n  var finalExpressionString = stringWithVariables.replace(/\\s/g, '_');\n  return new ExpressionQualifier(finalExpressionString);\n}\n// as a namespace\nvar Expression = {\n  expression: expression\n};\nexport { Expression, expression };","map":{"version":3,"names":["CONDITIONAL_OPERATORS","RESERVED_NAMES","ExpressionQualifier","expression","exp","reservedOperatorList","Object","keys","map","key","replace","regexSafeOperatorList","join","operatorsReplaceRE","RegExp","stringWithOperators","toString","match","trim","ReservedNames","regexSafeReservedNameList","reservedNamesRE","stringWithVariables","startsWith","finalExpressionString","Expression"],"sources":["/Users/tylerschnabel/Documents/the_odin_project/portfolio/node_modules/@cloudinary/transformation-builder-sdk/qualifiers/expression.js"],"sourcesContent":["import { CONDITIONAL_OPERATORS, RESERVED_NAMES } from \"../internal/internalConstants.js\";\nimport { ExpressionQualifier } from \"./expression/ExpressionQualifier.js\";\n/**\n * @description\n * Used for variable or conditional expressions\n * <b>Learn more:</b> {@link https://cloudinary.com/documentation/user_defined_variables#arithmetic_expressions|Arithmetic expressions }\n * @namespace Expression\n * @memberOf Qualifiers\n */\n/**\n * @summary qualifier\n * @memberOf Qualifiers.Expression\n * @return {Qualifiers.Expression.ExpressionQualifier}\n */\nfunction expression(exp) {\n    // Prepare the CONDITIONAL_OPERATORS object to be used in a regex\n    // Properly escape |, +, ^ and *\n    // This step also adds a regex space ( \\s ) around each operator, since these are only replaced when wrapped with spaces\n    // $foo * $bar is replaced to $foo_mul_$bar\n    // $foo*bar is treated AS-IS.\n    const reservedOperatorList = Object.keys(CONDITIONAL_OPERATORS).map((key) => {\n        return `\\\\s${key.replace(/(\\*|\\+|\\^|\\|)/g, '\\\\$1')}\\\\s`;\n    });\n    // reservedOperatorList is now an array of values, joining with | creates the regex list\n    const regexSafeOperatorList = reservedOperatorList.join('|');\n    const operatorsReplaceRE = new RegExp(`(${regexSafeOperatorList})`, \"g\");\n    // First, we replace all the operators\n    // Notice how we pad the matched operators with `_`, this is following the step above.\n    // This turns $foo * $bar into $foo_mul_$bar (notice how the spaces were replaced with an underscore\n    const stringWithOperators = exp.toString()\n        .replace(operatorsReplaceRE, (match) => {\n        // match contains spaces around the expression, we need to trim it as the original list\n        // does not contain spaces.\n        return `_${CONDITIONAL_OPERATORS[match.trim()]}_`;\n    });\n    // Handle reserved names (width, height, etc.)\n    const ReservedNames = Object.keys(RESERVED_NAMES);\n    const regexSafeReservedNameList = ReservedNames.join('|');\n    // Gather all statements that begin with a dollar sign, underscore or a space\n    // Gather all RESERVED NAMES\n    // $foo_bar is matched\n    // height is matched\n    const reservedNamesRE = new RegExp(`(\\\\$_*[^_ ]+)|${regexSafeReservedNameList}`, \"g\");\n    // Since this regex captures both user variables and our reserved keywords, we need to add some logic in the replacer\n    const stringWithVariables = stringWithOperators.replace(reservedNamesRE, (match) => {\n        // Do not do anything to user variables (anything starting with $)\n        if (match.startsWith('$')) {\n            return match;\n        }\n        else {\n            return RESERVED_NAMES[match] || match;\n        }\n    });\n    // Serialize remaining spaces with an underscore\n    const finalExpressionString = stringWithVariables.replace(/\\s/g, '_');\n    return new ExpressionQualifier(finalExpressionString);\n}\n// as a namespace\nconst Expression = {\n    expression\n};\nexport { Expression, expression };\n"],"mappings":"AAAA,SAASA,qBAAqB,EAAEC,cAAc,QAAQ,kCAAkC;AACxF,SAASC,mBAAmB,QAAQ,qCAAqC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,UAAU,CAACC,GAAG,EAAE;EACrB;EACA;EACA;EACA;EACA;EACA,IAAMC,oBAAoB,GAAGC,MAAM,CAACC,IAAI,CAACP,qBAAqB,CAAC,CAACQ,GAAG,CAAC,UAACC,GAAG,EAAK;IACzE,oBAAaA,GAAG,CAACC,OAAO,CAAC,gBAAgB,EAAE,MAAM,CAAC;EACtD,CAAC,CAAC;EACF;EACA,IAAMC,qBAAqB,GAAGN,oBAAoB,CAACO,IAAI,CAAC,GAAG,CAAC;EAC5D,IAAMC,kBAAkB,GAAG,IAAIC,MAAM,YAAKH,qBAAqB,QAAK,GAAG,CAAC;EACxE;EACA;EACA;EACA,IAAMI,mBAAmB,GAAGX,GAAG,CAACY,QAAQ,EAAE,CACrCN,OAAO,CAACG,kBAAkB,EAAE,UAACI,KAAK,EAAK;IACxC;IACA;IACA,kBAAWjB,qBAAqB,CAACiB,KAAK,CAACC,IAAI,EAAE,CAAC;EAClD,CAAC,CAAC;EACF;EACA,IAAMC,aAAa,GAAGb,MAAM,CAACC,IAAI,CAACN,cAAc,CAAC;EACjD,IAAMmB,yBAAyB,GAAGD,aAAa,CAACP,IAAI,CAAC,GAAG,CAAC;EACzD;EACA;EACA;EACA;EACA,IAAMS,eAAe,GAAG,IAAIP,MAAM,yBAAkBM,yBAAyB,GAAI,GAAG,CAAC;EACrF;EACA,IAAME,mBAAmB,GAAGP,mBAAmB,CAACL,OAAO,CAACW,eAAe,EAAE,UAACJ,KAAK,EAAK;IAChF;IACA,IAAIA,KAAK,CAACM,UAAU,CAAC,GAAG,CAAC,EAAE;MACvB,OAAON,KAAK;IAChB,CAAC,MACI;MACD,OAAOhB,cAAc,CAACgB,KAAK,CAAC,IAAIA,KAAK;IACzC;EACJ,CAAC,CAAC;EACF;EACA,IAAMO,qBAAqB,GAAGF,mBAAmB,CAACZ,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;EACrE,OAAO,IAAIR,mBAAmB,CAACsB,qBAAqB,CAAC;AACzD;AACA;AACA,IAAMC,UAAU,GAAG;EACftB,UAAU,EAAVA;AACJ,CAAC;AACD,SAASsB,UAAU,EAAEtB,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}