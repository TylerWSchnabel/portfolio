{"ast":null,"code":"import { encodeVersion } from \"./encodeVersion.js\";\nimport { getAnalyticsOptions } from \"./getAnalyticsOptions.js\";\nimport { packageVersion } from \"../internal/utils/packageVersion.js\";\n/**\n * @private\n * @description Try to get the node version out of process, if browser just return 0.0.0\n */\nfunction getNodeVersion() {\n  var failedVersion = '0.0.0';\n  if (typeof window !== 'undefined') {\n    return failedVersion;\n  } else {\n    // node env\n    try {\n      return process.versions.node || failedVersion;\n    } catch (e) {\n      return failedVersion;\n    }\n  }\n}\n/**\n * @private\n * @description Ensure that all values ITrackedPropertiesThroughAnalytics are populated.\n * Accept a partial map of values and returns the complete interface of ITrackedPropertiesThroughAnalytics\n * @param {ITrackedPropertiesThroughAnalytics} trackedAnalytics\n * @param {ITrackedPropertiesThroughAnalytics} trackedAnalytics\n */\nfunction ensureShapeOfTrackedProperties(trackedAnalytics) {\n  // try to get the process version from node, but if we're on the client return 0.0.0\n  var defaults = {\n    techVersion: getNodeVersion(),\n    sdkCode: 'T',\n    sdkSemver: packageVersion.split('-')[0],\n    responsive: false,\n    placeholder: false,\n    lazyload: false,\n    accessibility: false\n  };\n  if (!trackedAnalytics) {\n    return defaults;\n  } else {\n    return Object.assign(Object.assign({}, defaults), trackedAnalytics);\n  }\n}\n/**\n * @private\n * @description Creates the complete SDK signature by using all the values provided by ITrackedPropertiesThroughAnalytics\n *              Creation of the signature\n *              - Set the AlgoVersion of the encoding, this is an internal letter that represents the version\n *                of our encoding algorithm, it will allow us to perform breaking changes if we'll need them.\n *              - Take the constant SDK code (Arbitrary letter chosen for each SDK, for Base that letter is 'T')\n *                this is used to tell apart which SDK is being tracked.\n *              - Take the {major.minor} versions of the node version (techVersion) (14.2, 16.2 etc.)\n *              - Take the full semver of the SDK you wish to track\n *              - Take the features used(lazy, placeholder etc.) and turn them to a letter (for example accessibility -> D)\n *              - Before appending the string, the Versions must be encoded, see the function `encodeVersion` for more details\n *              - Append all the variables to a single string\n *              - In any case of an error, return the single letter 'E'\n *\n * @return {string} sdkAnalyticsSignature\n */\nexport function getSDKAnalyticsSignature(_trackedAnalytics) {\n  var trackedAnalytics = ensureShapeOfTrackedProperties(_trackedAnalytics);\n  var analyticsOptions = getAnalyticsOptions(trackedAnalytics);\n  try {\n    var twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);\n    var encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);\n    var encodedTechVersion = encodeVersion(twoPartVersion);\n    var featureCode = analyticsOptions.feature;\n    var SDKCode = analyticsOptions.sdkCode;\n    var algoVersion = 'A'; // The algo version is determined here, it should not be an argument\n    return \"\".concat(algoVersion).concat(SDKCode).concat(encodedSDKVersion).concat(encodedTechVersion).concat(featureCode);\n  } catch (e) {\n    // Either SDK or Node versions were unparsable\n    return 'E';\n  }\n}\n/**\n * @private\n * @description Removes patch version from the semver if it exists\n *              Turns x.y.z OR x.y into x.y\n * @param {'x.y.z' | 'x.y' | string} semVerStr\n */\nfunction removePatchFromSemver(semVerStr) {\n  var parts = semVerStr.split('.');\n  return \"\".concat(parts[0], \".\").concat(parts[1]);\n}","map":{"version":3,"names":["encodeVersion","getAnalyticsOptions","packageVersion","getNodeVersion","failedVersion","window","process","versions","node","e","ensureShapeOfTrackedProperties","trackedAnalytics","defaults","techVersion","sdkCode","sdkSemver","split","responsive","placeholder","lazyload","accessibility","Object","assign","getSDKAnalyticsSignature","_trackedAnalytics","analyticsOptions","twoPartVersion","removePatchFromSemver","encodedSDKVersion","encodedTechVersion","featureCode","feature","SDKCode","algoVersion","semVerStr","parts"],"sources":["/Users/tylerschnabel/Documents/the_odin_project/portfolio/node_modules/@cloudinary/url-gen/sdkAnalytics/getSDKAnalyticsSignature.js"],"sourcesContent":["import { encodeVersion } from \"./encodeVersion.js\";\nimport { getAnalyticsOptions } from \"./getAnalyticsOptions.js\";\nimport { packageVersion } from \"../internal/utils/packageVersion.js\";\n/**\n * @private\n * @description Try to get the node version out of process, if browser just return 0.0.0\n */\nfunction getNodeVersion() {\n    const failedVersion = '0.0.0';\n    if (typeof window !== 'undefined') {\n        return failedVersion;\n    }\n    else {\n        // node env\n        try {\n            return process.versions.node || failedVersion;\n        }\n        catch (e) {\n            return failedVersion;\n        }\n    }\n}\n/**\n * @private\n * @description Ensure that all values ITrackedPropertiesThroughAnalytics are populated.\n * Accept a partial map of values and returns the complete interface of ITrackedPropertiesThroughAnalytics\n * @param {ITrackedPropertiesThroughAnalytics} trackedAnalytics\n * @param {ITrackedPropertiesThroughAnalytics} trackedAnalytics\n */\nfunction ensureShapeOfTrackedProperties(trackedAnalytics) {\n    // try to get the process version from node, but if we're on the client return 0.0.0\n    const defaults = {\n        techVersion: getNodeVersion(),\n        sdkCode: 'T',\n        sdkSemver: packageVersion.split('-')[0],\n        responsive: false,\n        placeholder: false,\n        lazyload: false,\n        accessibility: false\n    };\n    if (!trackedAnalytics) {\n        return defaults;\n    }\n    else {\n        return Object.assign(Object.assign({}, defaults), trackedAnalytics);\n    }\n}\n/**\n * @private\n * @description Creates the complete SDK signature by using all the values provided by ITrackedPropertiesThroughAnalytics\n *              Creation of the signature\n *              - Set the AlgoVersion of the encoding, this is an internal letter that represents the version\n *                of our encoding algorithm, it will allow us to perform breaking changes if we'll need them.\n *              - Take the constant SDK code (Arbitrary letter chosen for each SDK, for Base that letter is 'T')\n *                this is used to tell apart which SDK is being tracked.\n *              - Take the {major.minor} versions of the node version (techVersion) (14.2, 16.2 etc.)\n *              - Take the full semver of the SDK you wish to track\n *              - Take the features used(lazy, placeholder etc.) and turn them to a letter (for example accessibility -> D)\n *              - Before appending the string, the Versions must be encoded, see the function `encodeVersion` for more details\n *              - Append all the variables to a single string\n *              - In any case of an error, return the single letter 'E'\n *\n * @return {string} sdkAnalyticsSignature\n */\nexport function getSDKAnalyticsSignature(_trackedAnalytics) {\n    const trackedAnalytics = ensureShapeOfTrackedProperties(_trackedAnalytics);\n    const analyticsOptions = getAnalyticsOptions(trackedAnalytics);\n    try {\n        const twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);\n        const encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);\n        const encodedTechVersion = encodeVersion(twoPartVersion);\n        const featureCode = analyticsOptions.feature;\n        const SDKCode = analyticsOptions.sdkCode;\n        const algoVersion = 'A'; // The algo version is determined here, it should not be an argument\n        return `${algoVersion}${SDKCode}${encodedSDKVersion}${encodedTechVersion}${featureCode}`;\n    }\n    catch (e) {\n        // Either SDK or Node versions were unparsable\n        return 'E';\n    }\n}\n/**\n * @private\n * @description Removes patch version from the semver if it exists\n *              Turns x.y.z OR x.y into x.y\n * @param {'x.y.z' | 'x.y' | string} semVerStr\n */\nfunction removePatchFromSemver(semVerStr) {\n    const parts = semVerStr.split('.');\n    return `${parts[0]}.${parts[1]}`;\n}\n"],"mappings":"AAAA,SAASA,aAAa,QAAQ,oBAAoB;AAClD,SAASC,mBAAmB,QAAQ,0BAA0B;AAC9D,SAASC,cAAc,QAAQ,qCAAqC;AACpE;AACA;AACA;AACA;AACA,SAASC,cAAc,GAAG;EACtB,IAAMC,aAAa,GAAG,OAAO;EAC7B,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;IAC/B,OAAOD,aAAa;EACxB,CAAC,MACI;IACD;IACA,IAAI;MACA,OAAOE,OAAO,CAACC,QAAQ,CAACC,IAAI,IAAIJ,aAAa;IACjD,CAAC,CACD,OAAOK,CAAC,EAAE;MACN,OAAOL,aAAa;IACxB;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,8BAA8B,CAACC,gBAAgB,EAAE;EACtD;EACA,IAAMC,QAAQ,GAAG;IACbC,WAAW,EAAEV,cAAc,EAAE;IAC7BW,OAAO,EAAE,GAAG;IACZC,SAAS,EAAEb,cAAc,CAACc,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACvCC,UAAU,EAAE,KAAK;IACjBC,WAAW,EAAE,KAAK;IAClBC,QAAQ,EAAE,KAAK;IACfC,aAAa,EAAE;EACnB,CAAC;EACD,IAAI,CAACT,gBAAgB,EAAE;IACnB,OAAOC,QAAQ;EACnB,CAAC,MACI;IACD,OAAOS,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEV,QAAQ,CAAC,EAAED,gBAAgB,CAAC;EACvE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASY,wBAAwB,CAACC,iBAAiB,EAAE;EACxD,IAAMb,gBAAgB,GAAGD,8BAA8B,CAACc,iBAAiB,CAAC;EAC1E,IAAMC,gBAAgB,GAAGxB,mBAAmB,CAACU,gBAAgB,CAAC;EAC9D,IAAI;IACA,IAAMe,cAAc,GAAGC,qBAAqB,CAACF,gBAAgB,CAACZ,WAAW,CAAC;IAC1E,IAAMe,iBAAiB,GAAG5B,aAAa,CAACyB,gBAAgB,CAACV,SAAS,CAAC;IACnE,IAAMc,kBAAkB,GAAG7B,aAAa,CAAC0B,cAAc,CAAC;IACxD,IAAMI,WAAW,GAAGL,gBAAgB,CAACM,OAAO;IAC5C,IAAMC,OAAO,GAAGP,gBAAgB,CAACX,OAAO;IACxC,IAAMmB,WAAW,GAAG,GAAG,CAAC,CAAC;IACzB,iBAAUA,WAAW,SAAGD,OAAO,SAAGJ,iBAAiB,SAAGC,kBAAkB,SAAGC,WAAW;EAC1F,CAAC,CACD,OAAOrB,CAAC,EAAE;IACN;IACA,OAAO,GAAG;EACd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkB,qBAAqB,CAACO,SAAS,EAAE;EACtC,IAAMC,KAAK,GAAGD,SAAS,CAAClB,KAAK,CAAC,GAAG,CAAC;EAClC,iBAAUmB,KAAK,CAAC,CAAC,CAAC,cAAIA,KAAK,CAAC,CAAC,CAAC;AAClC"},"metadata":{},"sourceType":"module","externalDependencies":[]}